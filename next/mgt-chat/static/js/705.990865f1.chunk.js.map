{"version":3,"file":"static/js/705.990865f1.chunk.js","mappings":"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","sources":["../../../node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.form-associated.js","../../../node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.js","../../../node_modules/@fluentui/web-components/dist/esm/checkbox/index.js","../../../node_modules/@microsoft/fast-foundation/dist/esm/checkbox/checkbox.template.js","../../../node_modules/@fluentui/web-components/dist/esm/checkbox/checkbox.styles.js","../../../node_modules/tabbable/src/index.js","../../../node_modules/@microsoft/fast-foundation/dist/esm/dialog/dialog.js","../../../node_modules/@fluentui/web-components/dist/esm/dialog/index.js","../../../node_modules/@microsoft/fast-foundation/dist/esm/dialog/dialog.template.js","../../../node_modules/@fluentui/web-components/dist/esm/dialog/dialog.styles.js","../../../node_modules/@fluentui/web-components/dist/esm/progress/progress/index.js","../../../node_modules/@microsoft/fast-foundation/dist/esm/progress/progress.template.js","../../../node_modules/@fluentui/web-components/dist/esm/progress/progress/progress.styles.js"],"sourcesContent":["import { CheckableFormAssociated } from \"../form-associated/form-associated.js\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\nclass _Checkbox extends FoundationElement {\n}\n/**\n * A form-associated base class for the {@link @microsoft/fast-foundation#(Checkbox:class)} component.\n *\n * @internal\n */\nexport class FormAssociatedCheckbox extends CheckableFormAssociated(_Checkbox) {\n    constructor() {\n        super(...arguments);\n        this.proxy = document.createElement(\"input\");\n    }\n}\n","import { __decorate } from \"tslib\";\nimport { attr, observable } from \"@microsoft/fast-element\";\nimport { keySpace } from \"@microsoft/fast-web-utilities\";\nimport { FormAssociatedCheckbox } from \"./checkbox.form-associated.js\";\n/**\n * A Checkbox Custom HTML Element.\n * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#checkbox | ARIA checkbox }.\n *\n * @slot checked-indicator - The checked indicator\n * @slot indeterminate-indicator - The indeterminate indicator\n * @slot - The default slot for the label\n * @csspart control - The element representing the visual checkbox control\n * @csspart label - The label\n * @fires change - Emits a custom change event when the checked state changes\n *\n * @public\n */\nexport class Checkbox extends FormAssociatedCheckbox {\n    constructor() {\n        super();\n        /**\n         * The element's value to be included in form submission when checked.\n         * Default to \"on\" to reach parity with input[type=\"checkbox\"]\n         *\n         * @internal\n         */\n        this.initialValue = \"on\";\n        /**\n         * The indeterminate state of the control\n         */\n        this.indeterminate = false;\n        /**\n         * @internal\n         */\n        this.keypressHandler = (e) => {\n            if (this.readOnly) {\n                return;\n            }\n            switch (e.key) {\n                case keySpace:\n                    if (this.indeterminate) {\n                        this.indeterminate = false;\n                    }\n                    this.checked = !this.checked;\n                    break;\n            }\n        };\n        /**\n         * @internal\n         */\n        this.clickHandler = (e) => {\n            if (!this.disabled && !this.readOnly) {\n                if (this.indeterminate) {\n                    this.indeterminate = false;\n                }\n                this.checked = !this.checked;\n            }\n        };\n        this.proxy.setAttribute(\"type\", \"checkbox\");\n    }\n    readOnlyChanged() {\n        if (this.proxy instanceof HTMLInputElement) {\n            this.proxy.readOnly = this.readOnly;\n        }\n    }\n}\n__decorate([\n    attr({ attribute: \"readonly\", mode: \"boolean\" })\n], Checkbox.prototype, \"readOnly\", void 0);\n__decorate([\n    observable\n], Checkbox.prototype, \"defaultSlottedNodes\", void 0);\n__decorate([\n    observable\n], Checkbox.prototype, \"indeterminate\", void 0);\n","import { Checkbox, checkboxTemplate as template } from '@microsoft/fast-foundation';\nimport { checkboxStyles as styles } from './checkbox.styles';\n/**\n * The Fluent Checkbox Element. Implements {@link @microsoft/fast-foundation#Checkbox},\n * {@link @microsoft/fast-foundation#checkboxTemplate}\n *\n *\n * @public\n * @remarks\n * HTML Element: \\<fluent-checkbox\\>\n */\nexport const fluentCheckbox = Checkbox.compose({\n    baseName: 'checkbox',\n    template,\n    styles,\n    checkedIndicator: `\n    <svg width=\"16\" height=\"16\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path d=\"M13.86 3.66a.5.5 0 01-.02.7l-7.93 7.48a.6.6 0 01-.84-.02L2.4 9.1a.5.5 0 01.72-.7l2.4 2.44 7.65-7.2a.5.5 0 01.7.02z\"/>\n    </svg>\n  `,\n    indeterminateIndicator: `\n    <svg width=\"16\" height=\"16\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path d=\"M3 8c0-.28.22-.5.5-.5h9a.5.5 0 010 1h-9A.5.5 0 013 8z\"/>\n    </svg>\n  `,\n});\n/**\n * Styles for Checkbox\n * @public\n */\nexport const checkboxStyles = styles;\n","import { html, slotted } from \"@microsoft/fast-element\";\n/**\n * The template for the {@link @microsoft/fast-foundation#(Checkbox:class)} component.\n * @public\n */\nexport const checkboxTemplate = (context, definition) => html `\n    <template\n        role=\"checkbox\"\n        aria-checked=\"${x => x.checked}\"\n        aria-required=\"${x => x.required}\"\n        aria-disabled=\"${x => x.disabled}\"\n        aria-readonly=\"${x => x.readOnly}\"\n        tabindex=\"${x => (x.disabled ? null : 0)}\"\n        @keypress=\"${(x, c) => x.keypressHandler(c.event)}\"\n        @click=\"${(x, c) => x.clickHandler(c.event)}\"\n        class=\"${x => (x.readOnly ? \"readonly\" : \"\")} ${x => x.checked ? \"checked\" : \"\"} ${x => (x.indeterminate ? \"indeterminate\" : \"\")}\"\n    >\n        <div part=\"control\" class=\"control\">\n            <slot name=\"checked-indicator\">\n                ${definition.checkedIndicator || \"\"}\n            </slot>\n            <slot name=\"indeterminate-indicator\">\n                ${definition.indeterminateIndicator || \"\"}\n            </slot>\n        </div>\n        <label\n            part=\"label\"\n            class=\"${x => x.defaultSlottedNodes && x.defaultSlottedNodes.length\n    ? \"label\"\n    : \"label label__hidden\"}\"\n        >\n            <slot ${slotted(\"defaultSlottedNodes\")}></slot>\n        </label>\n    </template>\n`;\n","import { css } from '@microsoft/fast-element';\nimport { disabledCursor, display, focusVisible, forcedColorsStylesheetBehavior, } from '@microsoft/fast-foundation';\nimport { SystemColors } from '@microsoft/fast-web-utilities';\nimport { heightNumber } from '../styles';\nimport { accentFillActive, accentFillHover, accentFillRest, controlCornerRadius, designUnit, disabledOpacity, foregroundOnAccentRest, neutralFillInputAltActive, neutralFillInputAltFocus, neutralFillInputAltHover, neutralFillInputAltRest, neutralForegroundRest, neutralStrokeStrongActive, neutralStrokeStrongHover, neutralStrokeStrongRest, strokeWidth, } from '../design-tokens';\nimport { typeRampBase } from '../styles/patterns/type-ramp';\nimport { focusTreatmentTight } from '../styles/focus';\nexport const checkboxStyles = (context, definition) => css `\n    ${display('inline-flex')} :host {\n      align-items: center;\n      outline: none;\n      ${\n/*\n * Chromium likes to select label text or the default slot when\n * the checkbox is clicked. Maybe there is a better solution here?\n */ ''} user-select: none;\n    }\n\n    .control {\n      position: relative;\n      width: calc((${heightNumber} / 2 + ${designUnit}) * 1px);\n      height: calc((${heightNumber} / 2 + ${designUnit}) * 1px);\n      box-sizing: border-box;\n      border-radius: calc(${controlCornerRadius} * 1px);\n      border: calc(${strokeWidth} * 1px) solid ${neutralStrokeStrongRest};\n      background: ${neutralFillInputAltRest};\n      cursor: pointer;\n    }\n\n    .label__hidden {\n      display: none;\n      visibility: hidden;\n    }\n\n    .label {\n      ${typeRampBase}\n      color: ${neutralForegroundRest};\n      ${\n/* Need to discuss with Brian how HorizontalSpacingNumber can work. https://github.com/microsoft/fast/issues/2766 */ ''} padding-inline-start: calc(${designUnit} * 2px + 2px);\n      margin-inline-end: calc(${designUnit} * 2px + 2px);\n      cursor: pointer;\n    }\n\n    slot[name='checked-indicator'],\n    slot[name='indeterminate-indicator'] {\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      width: 100%;\n      height: 100%;\n      fill: ${neutralForegroundRest};\n      opacity: 0;\n      pointer-events: none;\n    }\n\n    slot[name='indeterminate-indicator'] {\n      position: absolute;\n      top: 0;\n    }\n\n    :host(.checked) slot[name='checked-indicator'],\n    :host(.checked) slot[name='indeterminate-indicator'] {\n      fill: ${foregroundOnAccentRest};\n    }\n\n    :host(:not(.disabled):hover) .control {\n      background: ${neutralFillInputAltHover};\n      border-color: ${neutralStrokeStrongHover};\n    }\n\n    :host(:not(.disabled):active) .control {\n      background: ${neutralFillInputAltActive};\n      border-color: ${neutralStrokeStrongActive};\n    }\n\n    :host(:${focusVisible}) .control {\n      background: ${neutralFillInputAltFocus};\n      ${focusTreatmentTight}\n    }\n\n    :host(.checked) .control {\n      background: ${accentFillRest};\n      border-color: transparent;\n    }\n\n    :host(.checked:not(.disabled):hover) .control {\n      background: ${accentFillHover};\n      border-color: transparent;\n    }\n\n    :host(.checked:not(.disabled):active) .control {\n      background: ${accentFillActive};\n      border-color: transparent;\n    }\n\n    :host(.disabled) .label,\n    :host(.readonly) .label,\n    :host(.readonly) .control,\n    :host(.disabled) .control {\n      cursor: ${disabledCursor};\n    }\n\n    :host(.checked:not(.indeterminate)) slot[name='checked-indicator'],\n    :host(.indeterminate) slot[name='indeterminate-indicator'] {\n      opacity: 1;\n    }\n\n    :host(.disabled) {\n      opacity: ${disabledOpacity};\n    }\n  `.withBehaviors(forcedColorsStylesheetBehavior(css `\n        .control {\n          border-color: ${SystemColors.FieldText};\n          background: ${SystemColors.Field};\n        }\n        :host(:not(.disabled):hover) .control,\n        :host(:not(.disabled):active) .control {\n          border-color: ${SystemColors.Highlight};\n          background: ${SystemColors.Field};\n        }\n        slot[name='checked-indicator'],\n        slot[name='indeterminate-indicator'] {\n          fill: ${SystemColors.FieldText};\n        }\n        :host(:${focusVisible}) .control {\n          forced-color-adjust: none;\n          outline-color: ${SystemColors.FieldText};\n          background: ${SystemColors.Field};\n          border-color: ${SystemColors.Highlight};\n        }\n        :host(.checked) .control {\n          background: ${SystemColors.Highlight};\n          border-color: ${SystemColors.Highlight};\n        }\n        :host(.checked:not(.disabled):hover) .control,\n        :host(.checked:not(.disabled):active) .control {\n          background: ${SystemColors.HighlightText};\n          border-color: ${SystemColors.Highlight};\n        }\n        :host(.checked) slot[name='checked-indicator'],\n        :host(.checked) slot[name='indeterminate-indicator'] {\n          fill: ${SystemColors.HighlightText};\n        }\n        :host(.checked:hover ) .control slot[name='checked-indicator'],\n        :host(.checked:hover ) .control slot[name='indeterminate-indicator'] {\n          fill: ${SystemColors.Highlight};\n        }\n        :host(.disabled) {\n          opacity: 1;\n        }\n        :host(.disabled) .control {\n          border-color: ${SystemColors.GrayText};\n          background: ${SystemColors.Field};\n        }\n        :host(.disabled) slot[name='checked-indicator'],\n        :host(.checked.disabled:hover) .control slot[name='checked-indicator'],\n        :host(.disabled) slot[name='indeterminate-indicator'],\n        :host(.checked.disabled:hover) .control slot[name='indeterminate-indicator'] {\n          fill: ${SystemColors.GrayText};\n        }\n      `));\n","const candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]:not(slot)',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n  'details>summary:first-of-type',\n  'details',\n];\nconst candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');\n\nconst NoElement = typeof Element === 'undefined';\n\nconst matches = NoElement\n  ? function () {}\n  : Element.prototype.matches ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\n\nconst getRootNode =\n  !NoElement && Element.prototype.getRootNode\n    ? (element) => element.getRootNode()\n    : (element) => element.ownerDocument;\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nconst getCandidates = function (el, includeContainer, filter) {\n  let candidates = Array.prototype.slice.apply(\n    el.querySelectorAll(candidateSelector)\n  );\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidatesScope\n * @property {Element} scope contains inner candidates\n * @property {Element[]} candidates\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidatesScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidatesScope>}\n */\nconst getCandidatesIteratively = function (\n  elements,\n  includeContainer,\n  options\n) {\n  const candidates = [];\n  const elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    const element = elementsToCheck.shift();\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      const assigned = element.assignedElements();\n      const content = assigned.length ? assigned : element.children;\n      const nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push(...nestedCandidates);\n      } else {\n        candidates.push({\n          scope: element,\n          candidates: nestedCandidates,\n        });\n      }\n    } else {\n      // check candidate element\n      const validCandidate = matches.call(element, candidateSelector);\n      if (\n        validCandidate &&\n        options.filter(element) &&\n        (includeContainer || !elements.includes(element))\n      ) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      const shadowRoot =\n        element.shadowRoot ||\n        // check for an undisclosed shadow\n        (typeof options.getShadowRoot === 'function' &&\n          options.getShadowRoot(element));\n\n      const validShadowRoot =\n        !options.shadowRootFilter || options.shadowRootFilter(element);\n\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        const nestedCandidates = getCandidatesIteratively(\n          shadowRoot === true ? element.children : shadowRoot.children,\n          true,\n          options\n        );\n\n        if (options.flatten) {\n          candidates.push(...nestedCandidates);\n        } else {\n          candidates.push({\n            scope: element,\n            candidates: nestedCandidates,\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift(...element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\nconst getTabindex = function (node, isScope) {\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    //\n    // isScope is positive for custom element with shadow root or slot that by default\n    // have tabIndex -1, but need to be sorted by document order in order for their\n    // content to be inserted in the correct position\n    if (\n      (isScope ||\n        /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) ||\n        node.isContentEditable) &&\n      isNaN(parseInt(node.getAttribute('tabindex'), 10))\n    ) {\n      return 0;\n    }\n  }\n\n  return node.tabIndex;\n};\n\nconst sortOrderedTabbables = function (a, b) {\n  return a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex;\n};\n\nconst isInput = function (node) {\n  return node.tagName === 'INPUT';\n};\n\nconst isHiddenInput = function (node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nconst isDetailsWithSummary = function (node) {\n  const r =\n    node.tagName === 'DETAILS' &&\n    Array.prototype.slice\n      .apply(node.children)\n      .some((child) => child.tagName === 'SUMMARY');\n  return r;\n};\n\nconst getCheckedRadio = function (nodes, form) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nconst isTabbableRadio = function (node) {\n  if (!node.name) {\n    return true;\n  }\n  const radioScope = node.form || getRootNode(node);\n  const queryRadios = function (name) {\n    return radioScope.querySelectorAll(\n      'input[type=\"radio\"][name=\"' + name + '\"]'\n    );\n  };\n\n  let radioSet;\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.CSS !== 'undefined' &&\n    typeof window.CSS.escape === 'function'\n  ) {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s',\n        err.message\n      );\n      return false;\n    }\n  }\n\n  const checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nconst isRadio = function (node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nconst isNonTabbableRadio = function (node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nconst isZeroArea = function (node) {\n  const { width, height } = node.getBoundingClientRect();\n  return width === 0 && height === 0;\n};\nconst isHidden = function (node, { displayCheck, getShadowRoot }) {\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  const isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  const nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  const nodeRootHost = getRootNode(node).host;\n  const nodeIsAttached =\n    nodeRootHost?.ownerDocument.contains(nodeRootHost) ||\n    node.ownerDocument.contains(node);\n\n  if (!displayCheck || displayCheck === 'full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      const originalNode = node;\n      while (node) {\n        const parentElement = node.parentElement;\n        const rootNode = getRootNode(node);\n        if (\n          parentElement &&\n          !parentElement.shadowRoot &&\n          getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (nodeIsAttached) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck` mode\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nconst isDisabledFromFieldset = function (node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    let parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (let i = 0; i < parentNode.children.length; i++) {\n          const child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *')\n              ? true\n              : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\n\nconst isNodeMatchingSelectorFocusable = function (options, node) {\n  if (\n    node.disabled ||\n    isHiddenInput(node) ||\n    isHidden(node, options) ||\n    // For a details element with a summary, the summary element gets the focus\n    isDetailsWithSummary(node) ||\n    isDisabledFromFieldset(node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isNodeMatchingSelectorTabbable = function (options, node) {\n  if (\n    isNonTabbableRadio(node) ||\n    getTabindex(node) < 0 ||\n    !isNodeMatchingSelectorFocusable(options, node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isValidShadowRootTabbable = function (shadowHostNode) {\n  const tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidatesScope>} candidates\n * @returns Element[]\n */\nconst sortByOrder = function (candidates) {\n  const regularTabbables = [];\n  const orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    const isScope = !!item.scope;\n    const element = isScope ? item.scope : item;\n    const candidateTabindex = getTabindex(element, isScope);\n    const elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope\n        ? regularTabbables.push(...elements)\n        : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements,\n      });\n    }\n  });\n\n  return orderedTabbables\n    .sort(sortOrderedTabbables)\n    .reduce((acc, sortable) => {\n      sortable.isScope\n        ? acc.push(...sortable.content)\n        : acc.push(sortable.content);\n      return acc;\n    }, [])\n    .concat(regularTabbables);\n};\n\nconst tabbable = function (el, options) {\n  options = options || {};\n\n  let candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable,\n    });\n  } else {\n    candidates = getCandidates(\n      el,\n      options.includeContainer,\n      isNodeMatchingSelectorTabbable.bind(null, options)\n    );\n  }\n  return sortByOrder(candidates);\n};\n\nconst focusable = function (el, options) {\n  options = options || {};\n\n  let candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot,\n    });\n  } else {\n    candidates = getCandidates(\n      el,\n      options.includeContainer,\n      isNodeMatchingSelectorFocusable.bind(null, options)\n    );\n  }\n\n  return candidates;\n};\n\nconst isTabbable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nconst focusableCandidateSelector = /* #__PURE__ */ candidateSelectors\n  .concat('iframe')\n  .join(',');\n\nconst isFocusable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { tabbable, focusable, isTabbable, isFocusable };\n","import { __decorate } from \"tslib\";\nimport { attr, DOM, Observable } from \"@microsoft/fast-element\";\nimport { keyEscape, keyTab } from \"@microsoft/fast-web-utilities\";\nimport { isTabbable } from \"tabbable\";\nimport { FoundationElement } from \"../foundation-element/foundation-element.js\";\n/**\n * A Switch Custom HTML Element.\n * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#dialog | ARIA dialog }.\n *\n * @slot - The default slot for the dialog content\n * @csspart positioning-region - A wrapping element used to center the dialog and position the modal overlay\n * @csspart overlay - The modal dialog overlay\n * @csspart control - The dialog element\n * @fires cancel - Fires a custom 'cancel' event when the modal overlay is clicked\n * @fires close - Fires a custom 'close' event when the dialog is hidden\n *\n * @public\n */\nexport class Dialog extends FoundationElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * Indicates the element is modal. When modal, user mouse interaction will be limited to the contents of the element by a modal\n         * overlay.  Clicks on the overlay will cause the dialog to emit a \"dismiss\" event.\n         * @public\n         * @defaultValue - true\n         * @remarks\n         * HTML Attribute: modal\n         */\n        this.modal = true;\n        /**\n         * The hidden state of the element.\n         *\n         * @public\n         * @defaultValue - false\n         * @remarks\n         * HTML Attribute: hidden\n         */\n        this.hidden = false;\n        /**\n         * Indicates that the dialog should trap focus.\n         *\n         * @public\n         * @defaultValue - true\n         * @remarks\n         * HTML Attribute: trap-focus\n         */\n        this.trapFocus = true;\n        this.trapFocusChanged = () => {\n            if (this.$fastController.isConnected) {\n                this.updateTrapFocus();\n            }\n        };\n        /**\n         * @internal\n         */\n        this.isTrappingFocus = false;\n        this.handleDocumentKeydown = (e) => {\n            if (!e.defaultPrevented && !this.hidden) {\n                switch (e.key) {\n                    case keyEscape:\n                        this.dismiss();\n                        e.preventDefault();\n                        break;\n                    case keyTab:\n                        this.handleTabKeyDown(e);\n                        break;\n                }\n            }\n        };\n        this.handleDocumentFocus = (e) => {\n            if (!e.defaultPrevented && this.shouldForceFocus(e.target)) {\n                this.focusFirstElement();\n                e.preventDefault();\n            }\n        };\n        this.handleTabKeyDown = (e) => {\n            if (!this.trapFocus || this.hidden) {\n                return;\n            }\n            const bounds = this.getTabQueueBounds();\n            if (bounds.length === 0) {\n                return;\n            }\n            if (bounds.length === 1) {\n                // keep focus on single element\n                bounds[0].focus();\n                e.preventDefault();\n                return;\n            }\n            if (e.shiftKey && e.target === bounds[0]) {\n                bounds[bounds.length - 1].focus();\n                e.preventDefault();\n            }\n            else if (!e.shiftKey && e.target === bounds[bounds.length - 1]) {\n                bounds[0].focus();\n                e.preventDefault();\n            }\n            return;\n        };\n        this.getTabQueueBounds = () => {\n            const bounds = [];\n            return Dialog.reduceTabbableItems(bounds, this);\n        };\n        /**\n         * focus on first element of tab queue\n         */\n        this.focusFirstElement = () => {\n            const bounds = this.getTabQueueBounds();\n            if (bounds.length > 0) {\n                bounds[0].focus();\n            }\n            else {\n                if (this.dialog instanceof HTMLElement) {\n                    this.dialog.focus();\n                }\n            }\n        };\n        /**\n         * we should only focus if focus has not already been brought to the dialog\n         */\n        this.shouldForceFocus = (currentFocusElement) => {\n            return this.isTrappingFocus && !this.contains(currentFocusElement);\n        };\n        /**\n         * we should we be active trapping focus\n         */\n        this.shouldTrapFocus = () => {\n            return this.trapFocus && !this.hidden;\n        };\n        /**\n         *\n         *\n         * @internal\n         */\n        this.updateTrapFocus = (shouldTrapFocusOverride) => {\n            const shouldTrapFocus = shouldTrapFocusOverride === undefined\n                ? this.shouldTrapFocus()\n                : shouldTrapFocusOverride;\n            if (shouldTrapFocus && !this.isTrappingFocus) {\n                this.isTrappingFocus = true;\n                // Add an event listener for focusin events if we are trapping focus\n                document.addEventListener(\"focusin\", this.handleDocumentFocus);\n                DOM.queueUpdate(() => {\n                    if (this.shouldForceFocus(document.activeElement)) {\n                        this.focusFirstElement();\n                    }\n                });\n            }\n            else if (!shouldTrapFocus && this.isTrappingFocus) {\n                this.isTrappingFocus = false;\n                // remove event listener if we are not trapping focus\n                document.removeEventListener(\"focusin\", this.handleDocumentFocus);\n            }\n        };\n    }\n    /**\n     * @internal\n     */\n    dismiss() {\n        this.$emit(\"dismiss\");\n        // implement `<dialog>` interface\n        this.$emit(\"cancel\");\n    }\n    /**\n     * The method to show the dialog.\n     *\n     * @public\n     */\n    show() {\n        this.hidden = false;\n    }\n    /**\n     * The method to hide the dialog.\n     *\n     * @public\n     */\n    hide() {\n        this.hidden = true;\n        // implement `<dialog>` interface\n        this.$emit(\"close\");\n    }\n    /**\n     * @internal\n     */\n    connectedCallback() {\n        super.connectedCallback();\n        document.addEventListener(\"keydown\", this.handleDocumentKeydown);\n        this.notifier = Observable.getNotifier(this);\n        this.notifier.subscribe(this, \"hidden\");\n        this.updateTrapFocus();\n    }\n    /**\n     * @internal\n     */\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        // remove keydown event listener\n        document.removeEventListener(\"keydown\", this.handleDocumentKeydown);\n        // if we are trapping focus remove the focusin listener\n        this.updateTrapFocus(false);\n        this.notifier.unsubscribe(this, \"hidden\");\n    }\n    /**\n     * @internal\n     */\n    handleChange(source, propertyName) {\n        switch (propertyName) {\n            case \"hidden\":\n                this.updateTrapFocus();\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Reduce a collection to only its focusable elements.\n     *\n     * @param elements - Collection of elements to reduce\n     * @param element - The current element\n     *\n     * @internal\n     */\n    static reduceTabbableItems(elements, element) {\n        if (element.getAttribute(\"tabindex\") === \"-1\") {\n            return elements;\n        }\n        if (isTabbable(element) ||\n            (Dialog.isFocusableFastElement(element) && Dialog.hasTabbableShadow(element))) {\n            elements.push(element);\n            return elements;\n        }\n        if (element.childElementCount) {\n            return elements.concat(Array.from(element.children).reduce(Dialog.reduceTabbableItems, []));\n        }\n        return elements;\n    }\n    /**\n     * Test if element is focusable fast element\n     *\n     * @param element - The element to check\n     *\n     * @internal\n     */\n    static isFocusableFastElement(element) {\n        var _a, _b;\n        return !!((_b = (_a = element.$fastController) === null || _a === void 0 ? void 0 : _a.definition.shadowOptions) === null || _b === void 0 ? void 0 : _b.delegatesFocus);\n    }\n    /**\n     * Test if the element has a focusable shadow\n     *\n     * @param element - The element to check\n     *\n     * @internal\n     */\n    static hasTabbableShadow(element) {\n        var _a, _b;\n        return Array.from((_b = (_a = element.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll(\"*\")) !== null && _b !== void 0 ? _b : []).some(x => {\n            return isTabbable(x);\n        });\n    }\n}\n__decorate([\n    attr({ mode: \"boolean\" })\n], Dialog.prototype, \"modal\", void 0);\n__decorate([\n    attr({ mode: \"boolean\" })\n], Dialog.prototype, \"hidden\", void 0);\n__decorate([\n    attr({ attribute: \"trap-focus\", mode: \"boolean\" })\n], Dialog.prototype, \"trapFocus\", void 0);\n__decorate([\n    attr({ attribute: \"aria-describedby\" })\n], Dialog.prototype, \"ariaDescribedby\", void 0);\n__decorate([\n    attr({ attribute: \"aria-labelledby\" })\n], Dialog.prototype, \"ariaLabelledby\", void 0);\n__decorate([\n    attr({ attribute: \"aria-label\" })\n], Dialog.prototype, \"ariaLabel\", void 0);\n","import { Dialog, dialogTemplate as template } from '@microsoft/fast-foundation';\nimport { dialogStyles as styles } from './dialog.styles';\n/**\n * The Fluent Dialog Element. Implements {@link @microsoft/fast-foundation#Dialog},\n * {@link @microsoft/fast-foundation#dialogTemplate}\n *\n *\n * @public\n * @remarks\n * HTML Element: \\<fluent-dialog\\>\n */\nexport const fluentDialog = Dialog.compose({\n    baseName: 'dialog',\n    template,\n    styles,\n});\n/**\n * Styles for Dialog\n * @public\n */\nexport const dialogStyles = styles;\n/**\n * Base Dialog Class\n * @public\n */\nexport { Dialog };\n","import { html, ref, when } from \"@microsoft/fast-element\";\n/**\n * The template for the {@link @microsoft/fast-foundation#Dialog} component.\n * @public\n */\nexport const dialogTemplate = (context, definition) => html `\n    <div class=\"positioning-region\" part=\"positioning-region\">\n        ${when(x => x.modal, html `\n                <div\n                    class=\"overlay\"\n                    part=\"overlay\"\n                    role=\"presentation\"\n                    @click=\"${x => x.dismiss()}\"\n                ></div>\n            `)}\n        <div\n            role=\"dialog\"\n            tabindex=\"-1\"\n            class=\"control\"\n            part=\"control\"\n            aria-modal=\"${x => x.modal}\"\n            aria-describedby=\"${x => x.ariaDescribedby}\"\n            aria-labelledby=\"${x => x.ariaLabelledby}\"\n            aria-label=\"${x => x.ariaLabel}\"\n            ${ref(\"dialog\")}\n        >\n            <slot></slot>\n        </div>\n    </div>\n`;\n","import { css } from '@microsoft/fast-element';\nimport { elevationShadowDialog } from '../styles';\nimport { fillColor, layerCornerRadius, strokeWidth } from '../design-tokens';\nexport const dialogStyles = (context, definition) => css `\n  :host([hidden]) {\n    display: none;\n  }\n\n  :host {\n    --dialog-height: 480px;\n    --dialog-width: 640px;\n    display: block;\n  }\n\n  .overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 0.3);\n    touch-action: none;\n  }\n\n  .positioning-region {\n    display: flex;\n    justify-content: center;\n    position: fixed;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    overflow: auto;\n  }\n\n  .control {\n    box-shadow: ${elevationShadowDialog};\n    margin-top: auto;\n    margin-bottom: auto;\n    border-radius: calc(${layerCornerRadius} * 1px);\n    width: var(--dialog-width);\n    height: var(--dialog-height);\n    background: ${fillColor};\n    z-index: 1;\n    border: calc(${strokeWidth} * 1px) solid transparent;\n  }\n`;\n","import { BaseProgress, progressTemplate as template } from '@microsoft/fast-foundation';\nimport { progressStyles as styles } from './progress.styles';\n/**\n * Progress base class\n * @public\n */\nexport class Progress extends BaseProgress {\n}\n/**\n * The Fluent Progress Element. Implements {@link @microsoft/fast-foundation#BaseProgress},\n * {@link @microsoft/fast-foundation#progressTemplate}\n *\n *\n * @public\n * @remarks\n * HTML Element: \\<fluent-progress\\>\n */\nexport const fluentProgress = Progress.compose({\n    baseName: 'progress',\n    template,\n    styles,\n    indeterminateIndicator1: `\n    <span class=\"indeterminate-indicator-1\" part=\"indeterminate-indicator-1\"></span>\n  `,\n    indeterminateIndicator2: `\n    <span class=\"indeterminate-indicator-2\" part=\"indeterminate-indicator-2\"></span>\n  `,\n});\n/**\n * Styles for Progress\n * @public\n */\nexport const progressStyles = styles;\n","import { html, when } from \"@microsoft/fast-element\";\n/**\n * The template for the {@link @microsoft/fast-foundation#BaseProgress} component.\n * @public\n */\nexport const progressTemplate = (context, defintion) => html `\n    <template\n        role=\"progressbar\"\n        aria-valuenow=\"${x => x.value}\"\n        aria-valuemin=\"${x => x.min}\"\n        aria-valuemax=\"${x => x.max}\"\n        class=\"${x => (x.paused ? \"paused\" : \"\")}\"\n    >\n        ${when(x => typeof x.value === \"number\", html `\n                <div class=\"progress\" part=\"progress\" slot=\"determinate\">\n                    <div\n                        class=\"determinate\"\n                        part=\"determinate\"\n                        style=\"width: ${x => x.percentComplete}%\"\n                    ></div>\n                </div>\n            `, html `\n                <div class=\"progress\" part=\"progress\" slot=\"indeterminate\">\n                    <slot class=\"indeterminate\" name=\"indeterminate\">\n                        ${defintion.indeterminateIndicator1 || \"\"}\n                        ${defintion.indeterminateIndicator2 || \"\"}\n                    </slot>\n                </div>\n            `)}\n    </template>\n`;\n","import { css } from '@microsoft/fast-element';\nimport { SystemColors } from '@microsoft/fast-web-utilities';\nimport { display, forcedColorsStylesheetBehavior, } from '@microsoft/fast-foundation';\nimport { accentFillRest, designUnit, neutralForegroundHint, neutralStrokeStrongRest, strokeWidth, } from '../../design-tokens';\nexport const progressStyles = (context, definition) => css `\n    ${display('flex')} :host {\n      align-items: center;\n      height: calc((${strokeWidth} * 3) * 1px);\n    }\n\n    .progress {\n      background-color: ${neutralStrokeStrongRest};\n      border-radius: calc(${designUnit} * 1px);\n      width: 100%;\n      height: calc(${strokeWidth} * 1px);\n      display: flex;\n      align-items: center;\n      position: relative;\n    }\n\n    .determinate {\n      background-color: ${accentFillRest};\n      border-radius: calc(${designUnit} * 1px);\n      height: calc((${strokeWidth} * 3) * 1px);\n      transition: all 0.2s ease-in-out;\n      display: flex;\n    }\n\n    .indeterminate {\n      height: calc((${strokeWidth} * 3) * 1px);\n      border-radius: calc(${designUnit} * 1px);\n      display: flex;\n      width: 100%;\n      position: relative;\n      overflow: hidden;\n    }\n\n    .indeterminate-indicator-1 {\n      position: absolute;\n      opacity: 0;\n      height: 100%;\n      background-color: ${accentFillRest};\n      border-radius: calc(${designUnit} * 1px);\n      animation-timing-function: cubic-bezier(0.4, 0, 0.6, 1);\n      width: 40%;\n      animation: indeterminate-1 2s infinite;\n    }\n\n    .indeterminate-indicator-2 {\n      position: absolute;\n      opacity: 0;\n      height: 100%;\n      background-color: ${accentFillRest};\n      border-radius: calc(${designUnit} * 1px);\n      animation-timing-function: cubic-bezier(0.4, 0, 0.6, 1);\n      width: 60%;\n      animation: indeterminate-2 2s infinite;\n    }\n\n    :host(.paused) .indeterminate-indicator-1,\n    :host(.paused) .indeterminate-indicator-2 {\n      animation: none;\n      background-color: ${neutralForegroundHint};\n      width: 100%;\n      opacity: 1;\n    }\n\n    :host(.paused) .determinate {\n      background-color: ${neutralForegroundHint};\n    }\n\n    @keyframes indeterminate-1 {\n      0% {\n        opacity: 1;\n        transform: translateX(-100%);\n      }\n      70% {\n        opacity: 1;\n        transform: translateX(300%);\n      }\n      70.01% {\n        opacity: 0;\n      }\n      100% {\n        opacity: 0;\n        transform: translateX(300%);\n      }\n    }\n\n    @keyframes indeterminate-2 {\n      0% {\n        opacity: 0;\n        transform: translateX(-150%);\n      }\n      29.99% {\n        opacity: 0;\n      }\n      30% {\n        opacity: 1;\n        transform: translateX(-150%);\n      }\n      100% {\n        transform: translateX(166.66%);\n        opacity: 1;\n      }\n    }\n  `.withBehaviors(forcedColorsStylesheetBehavior(css `\n        .indeterminate-indicator-1,\n        .indeterminate-indicator-2,\n        .determinate,\n        .progress {\n          background-color: ${SystemColors.ButtonText};\n        }\n        :host(.paused) .indeterminate-indicator-1,\n        :host(.paused) .indeterminate-indicator-2,\n        :host(.paused) .determinate {\n          background-color: ${SystemColors.GrayText};\n        }\n      `));\n"],"names":["_Checkbox","_FoundationElement","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","FoundationElement","FormAssociatedCheckbox","_CheckableFormAssocia","_super2","_this","proxy","document","createElement","CheckableFormAssociated","Checkbox","_FormAssociatedCheckb","call","initialValue","indeterminate","keypressHandler","e","readOnly","key","keySpace","checked","clickHandler","disabled","setAttribute","value","this","HTMLInputElement","__decorate","attr","attribute","mode","prototype","observable","fluentCheckbox","compose","baseName","template","context","definition","html","_templateObject","_taggedTemplateLiteral","x","required","c","event","checkedIndicator","indeterminateIndicator","defaultSlottedNodes","length","slotted","styles","css","display","heightNumber","designUnit","controlCornerRadius","strokeWidth","neutralStrokeStrongRest","neutralFillInputAltRest","typeRampBase","neutralForegroundRest","foregroundOnAccentRest","neutralFillInputAltHover","neutralStrokeStrongHover","neutralFillInputAltActive","neutralStrokeStrongActive","focusVisible","neutralFillInputAltFocus","focusTreatmentTight","accentFillRest","accentFillHover","accentFillActive","disabledCursor","disabledOpacity","withBehaviors","forcedColorsStylesheetBehavior","_templateObject2","SystemColors","FieldText","Field","Highlight","HighlightText","GrayText","candidateSelectors","candidateSelector","join","NoElement","Element","matches","msMatchesSelector","webkitMatchesSelector","getRootNode","element","ownerDocument","getTabindex","node","isScope","tabIndex","test","tagName","isContentEditable","isNaN","parseInt","getAttribute","isInput","isNonTabbableRadio","type","isRadio","name","radioSet","radioScope","form","queryRadios","querySelectorAll","window","CSS","escape","err","console","error","message","nodes","i","getCheckedRadio","isTabbableRadio","isZeroArea","_node$getBoundingClie","getBoundingClientRect","width","height","isNodeMatchingSelectorFocusable","options","isHiddenInput","_ref","displayCheck","getShadowRoot","getComputedStyle","visibility","nodeUnderDetails","parentElement","nodeRootHost","host","nodeIsAttached","contains","originalNode","rootNode","shadowRoot","assignedSlot","getClientRects","isHidden","Array","slice","children","some","child","isDetailsWithSummary","parentNode","item","isDisabledFromFieldset","isNodeMatchingSelectorTabbable","isTabbable","Error","Dialog","modal","hidden","trapFocus","trapFocusChanged","$fastController","isConnected","updateTrapFocus","isTrappingFocus","handleDocumentKeydown","defaultPrevented","keyEscape","dismiss","preventDefault","keyTab","handleTabKeyDown","handleDocumentFocus","shouldForceFocus","target","focusFirstElement","bounds","getTabQueueBounds","focus","shiftKey","reduceTabbableItems","_assertThisInitialized","dialog","HTMLElement","currentFocusElement","shouldTrapFocus","shouldTrapFocusOverride","undefined","addEventListener","DOM","queueUpdate","activeElement","removeEventListener","$emit","_get","_getPrototypeOf","notifier","Observable","getNotifier","subscribe","unsubscribe","source","propertyName","elements","isFocusableFastElement","hasTabbableShadow","push","childElementCount","concat","from","reduce","_a","_b","shadowOptions","delegatesFocus","fluentDialog","when","ariaDescribedby","ariaLabelledby","ariaLabel","ref","elevationShadowDialog","layerCornerRadius","fillColor","Progress","_BaseProgress","BaseProgress","fluentProgress","defintion","min","max","paused","percentComplete","_templateObject3","indeterminateIndicator1","indeterminateIndicator2","neutralForegroundHint","ButtonText"],"sourceRoot":""}